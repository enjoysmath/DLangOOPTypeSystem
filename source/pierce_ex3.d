module pierce_ex3;

module pierce_ex2;

import pierce_ex1;
import std.conv: to;

import pegged.grammar;


enum grammarName = "BoolNatLangForTyping";

enum ourGrammar = grammarName ~ `:
Term           < LambdaApp / LambdaAbstr / Var
LambdaAbstr    < Lambda ":" Type "." Term
LambdaApp      < Term Term
Lambda         <- "\lambda" / "λ"
Type           < Functions / Bool / Nat 
Functions      < Type RightArrow Type
RightArrow     <- "\to" / "->" / "→"
BoolVal        < "true" / "false"
NatVal         < ~([0-9]+)
Bool           < "Bool"
Nat            < "Nat"
Var            <- identifier
`;

class Term
{
   
}

class Var
{
public:
   this(string sym)
   {
      symbols = sym;
   }

private:
   string symbols;
}

struct Context
{
public:
   this(Term[] init)
   {
      list = init;
   }

private:
   Term[] list;

}

mixin(grammar(ourGrammar));

/**  
* @param ParseTree parseTree: generated by ArithmeticNoVar
* @return Hopefully the type of a bool / nat expression in this small language.
*/
string typingOfBoolNatLang(ParseTree parseTree)
{
   // TODO test remove
   import std.stdio;
   uint res = -1;

   switch (parseTree.name)
   {
      case grammarName:
      case grammarName ~ ".Term":
         return typingOfBoolNatLang(parseTree.children[0]);
      case grammarName ~ ".SuccFun":
      case grammarName ~ ".PredFun":
         return "Nat";

      case grammarName ~ ".IfThen":
         auto ifCond = evaluateBoolNatLang(parseTree.children[0]);

         if (ifCond)
            return typingOfBoolNatLang(parseTree.children[1]);
         else
            return typingOfBoolNatLang(parseTree.children[2]);

      case grammarName ~ ".IsZero":
      case grammarName ~ ".BoolVal":
         return "Bool";

      case grammarName ~ ".NatVal":
         return "Nat";

      default:
         return "(Stuck)";
   }
}
















