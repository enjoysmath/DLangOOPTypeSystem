module grammar_ex3;

import pierce_ex1;
import std.conv: to;
import std.bigint;


import pegged.grammar;


enum grammarName = "BoolNatLangForTyping";

enum ourGrammar = grammarName ~ `:
   Term           < LambdaApp / LambdaAbstr / Var
   LambdaAbstr    < Lambda Var ":" Type "." Term
   LambdaApp      < Term Term
   Lambda         <- "\\lambda" / "λ"
   Type           < Functions / Nat 
   Functions      < Type RightArrow Type
   RightArrow     <- "\\to" / "->" / "→"
   Nat            < "Nat"
   Var            <- identifier
`;

class Term
{
public:
   abstract Term evaluate()
   {
      return this;
   }

   abstract override string toString();
}

class ZZ : Term
{
public:
   alias value this;

   this(string val)
   {
      value = val;
   }

   this(long val)
   {
      value = val;
   }

   ZZ opBinary(string op)(long b)
   {
      auto z = ZZ(b);
      return opBinary!op(z);
   }

   ZZ opBinary(string op)(ZZ b)
   {
      alias a = this;

      static if (op == "+")
      {
         return new AddZZ(a, b);
      }
      else if (op == "-")
      {
         return new SubZZ(a,b);
      }
   }
private:
   BigInt value;
}

class BinaryZZ : ZZ
{
public:
   this(ZZ lhs, ZZ rhs)
   {
      super(0);
      this.rhs = rhs;
      this.lhs = lhs;
   }

private:
   ZZ lhs;
   ZZ rhs;
}

class AddZZ : BinaryZZ
{
public:
   this(ZZ a, ZZ b) 
   {
      super(a,b);
   }
}

class SubZZ : BinaryZZ
{
public:
   this(ZZ a, ZZ b) 
   {
      super(a,b);
   }
}


class Nat : ZZ
{
public:
   this(string val)
   in {
      assert (BigInt(val) >= 0);
   }
   do {
      super(val);
   }


private:

}

class Var : Term
{
public:
   this(string sym)
   {
      symbols = sym;
   }

private:
   string symbols;
}

class LambdaApp : Term
{

}

class LambdaAbstr : Term
{

}

struct Context
{
public:
   this(Term[] init)
   {
      list = init;
   }

private:
   Term[] list;

}

LambdaAbstr Successor;
Var n;

static this()
{
   n = new Var("n");
   Successor = new LambdaAbstr(n, "Nat", n + 1);
}

class ErrorTerm : Term
{
public:
   this(string errorMsg)
   {
      msg = errorMsg;
   }

private:
   string msg;
}

mixin(grammar(ourGrammar));

/**  
* @param ParseTree parseTree: generated by BoolNatLangForTyping
* @return Hopefully the type of a bool / nat / lambda expression in this small language.
*/
Term evaluateBoolNatLangForTyping(ParseTree parseTree)
{
   // TODO test remove
   import std.stdio;
   uint res = -1;

   switch (parseTree.name)
   {
      case grammarName:
      case grammarName ~ ".Term":
         return evaluateBoolNatLangForTyping(parseTree.children[0]);
      case grammarName ~ ".SuccFun":
      case grammarName ~ ".PredFun":
         auto arg = evaluateBoolNatLangForTyping(parseTree.children[0]);
         return arg;

      case grammarName ~ ".IfThen":
         auto ifCond = evaluateBoolNatLang(parseTree.children[0]);

         if (ifCond)
            return evaluateBoolNatLangForTyping(parseTree.children[1]);
         else
            return evaluateBoolNatLangForTyping(parseTree.children[2]);

      case grammarName ~ ".IsZero":

      case grammarName ~ ".NatVal":

         return new Nat("-1");

      case grammarName ~ ".Var":
         writeln(parseTree);
         return new Var(to!string(parseTree));

      default:
         return new ErrorTerm("Stuck");
   }
}
















